---
title: "Plotting a figure of shares of sales in different provinces"
author: "José Ignacio González Rojas"
date: "19/5/2020"
output: 
  pdf_document:
    toc: yes
    df_print: paged
    number_sections: yes
header-includes:
- \usepackage{amsmath}
- \usepackage{amssymb}
- \usepackage{mathpazo}
---

# General information

The purpose of this code is divided in two main objectives. 

The first one is to calculate the number of sellers from province P to province P'. Then, to compute the share of the largest seller of province P to province P'. Also, the share of sellers in PP' that have transactions among each other. Aditionally, the distances in between the provinces P and P'. As well as the share of the largest seller of the sector S to sector S'. Finally, multiple regressions by the pair of sectors SS' to explain the decision of a seller firm in a specific sector to trade with a buyer firm in the sector S' explained by the log of the distance between the provinces P and P'. 

The second objective is to plot an area graphic with the provinces in the X-axis, sorted ascendently by the share of the largest seller of the province P to the province P', and in the Y-axis the number of sellers in the provinces. In adition to plot the constants of the regressions with respect to the share of the largest seller in SS'. 

## Input files

1. `0-Raw_Data/Sales/sales_states.csv` The file has 6 columns. The year, the identity of the firm that sells the product "seller", the identity of the firm that buys the product "buyer", the province where the seller lives "state_seller", the province where the buyer lives "state_buyer", and finally, the amount of the sale "amount". 
2. `0-Raw_Data/Sales/coordinates.csv` The file has 3 columns: the state, the longitude and latitude. 

## Output files

1. `3-Graphics/a1.eps` This file contains a graphic with the provinces in the X-axis, sorted ascendently by the share of the largest seller of the province P to the province P', and in the Y-axis the number of sellers in the provinces. 
2. `3-Graphics/a1.png`
3. `3-Graphics/a1.pdf`
4. `3-Graphics/a2.eps`
5. `3-Graphics/a2.png`
6. `3-Graphics/a2.pdf`
7. `3-Graphics/b.eps`
8. `3-Graphics/b.png`
9. `3-Graphics/b.pdf`
10. `3-Graphics/l1.eps`
11. `3-Graphics/l1.png`
12. `3-Graphics/l1.pdf`
13. `3-Graphics/l2.eps`
14. `3-Graphics/l2.png`
15. `3-Graphics/l2.pdf`
16. `3-Graphics/a1_s.eps` This file contains a graphic with the sector in the X-axis, sorted ascendently by the share of the largest seller of the sector P to the sector P', and in the Y-axis the constant of the respective regression.
17. `3-Graphics/a1_s.png`
18. `3-Graphics/a1_s.pdf`
19. `3-Graphics/a2_s.eps`
20. `3-Graphics/a2_s.png`
21. `3-Graphics/a2_s.pdf`
22. `3-Graphics/b_s.eps`
23. `3-Graphics/b_s.png`
24. `3-Graphics/b_s.pdf`
25. `3-Graphics/l1_s.eps`
26. `3-Graphics/l1_s.png`
27. `3-Graphics/l1_s.pdf`
28. `3-Graphics/l2_s.eps`
29. `3-Graphics/l2_s.png`
30. `3-Graphics/l2_s.pdf`

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
remove(list = ls())
options(tinytex.verbose = TRUE)
```


```{r packages, message=FALSE, warning=FALSE, cache=FALSE, include=FALSE, results='hide'}
# libraries
# vector of libraries to be used

libs <- c("dplyr", "tidyr", "styler", "lintr", "readr", "janitor", "ggplot2", "broom", "geosphere", "reshape")

# Installing libraries in case they are not installed

for(i in length(libs)){ 
  if(!(libs[i] %in% installed.packages())) install.packages(libs) 
}

# Load corresponding libraries

lapply(libs, require, character.only=TRUE)
```

# Importing data to R

In this step, the data needed it's imported into R. Note that the data sets are in Comma-Separated Values format, so that's why the library "readr" was loaded.

```{r data-importing, echo=TRUE}
# Main inputs

sales_states <- read_csv("0-Raw_Data/Sales/sales_states.csv")
coordinates1 <- read_csv("0-Raw_Data/Sales/coordinates.csv")
```

# Cleaning the data

## Cleaning variable names

The library "janitor" helps standardizing the variable names to the *snake_case*'s format. 

```{r cleaning-variable-names, echo=TRUE}
sales_states <- janitor::clean_names(sales_states)
coordinates1 <- janitor::clean_names(coordinates1)
```

# Manipulating the data

Before plotting the requested graphics, the data needs to manipulated in order to create some variables. 

## Computing the number of sellers in the observation PP'

The number of sellers from province P to province P' is calculated by counting the seller that made at least one transaction. 

```{r number-of-sellers, echo=TRUE}
number_of_sellers <- sales_states %>%
  group_by(state_seller, state_buyer) %>%
  count(seller) %>% 
  count() %>% 
  ungroup()
```

## Calculating the share of the largest seller in the observation PP'

The share of the largest seller in the observation PP' calculus can be splitted in two parts. First, the sum of all the sales of a seller i in the observation PP'. Then, the sales of everyone in the observation PP'. Finally, the shares are calculated and the maximum observation is selected. 

```{r share-of-the-largest-seller, echo=TRUE}
share_largest_seller <- sales_states %>%
  group_by(state_seller, state_buyer, seller) %>% 
  mutate(seller_sales = sum(amount)) %>% 
  ungroup() %>% 
  group_by(state_seller, state_buyer) %>%
  transmute(share = seller_sales / sum(amount)) %>% 
  select(state_seller, state_buyer, share) %>% 
  top_n(1, share) %>% 
  unique()
```

## Computing the share of sellers in the observation PP'

The share of the sellers in the observation PP' is the number of sellers divided by the number of observations PP'. 

```{r share-of-sellers, echo=TRUE}
share_of_sellers <- number_of_sellers %>% 
  mutate(total = n()) %>% 
  mutate(share_sellers = n / total)
```

## Calculating the share of the largest seller in the observation SS'

The share of the largest seller in the observation PP' calculus can be splitted in two parts. First, the sum of all the sales of a seller i in the observation PP'. Then, the sales of everyone in the observation PP'. Finally, the shares are calculated and the maximum observation is selected. Note the year of interest is 2000. 

```{r share-of-the-largest-seller-s, echo=TRUE}
yr <- 2000

share_largest_seller_s <- sales_states %>%
  filter(year == yr) %>% 
  group_by(sector_seller, sector_buyer, seller) %>% 
  mutate(seller_sales_s = sum(amount)) %>% 
  ungroup() %>% 
  group_by(sector_seller, sector_buyer) %>%
  transmute(share_s = seller_sales_s / sum(amount)) %>% 
  select(sector_seller, sector_buyer, share_s) %>% 
  top_n(1, share_s) %>% 
  unique()
```

## Expanding the data set

Here the data set of the coordinates it's expanded and all the possible combinations are found. First, an identical data set it's needed with different column names. 

```{r expansion, echo=TRUE}
# Duplicate the dataset

coordinates2 <- coordinates1

colnames(coordinates1) <- paste(colnames(coordinates1), "1", sep="") #Adds 1 at the end of the variable name
colnames(coordinates2) <- paste(colnames(coordinates2), "2", sep="") #Adds 2 at the end of the variable name

coordinates <- expand.grid.df(coordinates1, coordinates2) # Combines all the rows in every possible way 
```

## Calculating the distances in the observations PP'

The distances between two provinces P and P' are calculated with the standard formula. If the distance between two provinces is zero, it's changed to 1. Then, the log is applied to the distances. 

```{r distances, echo=TRUE}
distances <- coordinates %>% 
  rowwise() %>% # The next operation can't be made with matrix vectorization, that's why it's computed row by row. 
  mutate(dist = distGeo(c(lon1, lat1), c(lon2, lat2)) / 1000) %>% 
  mutate(dist = if_else(dist == 0, 1, dist))%>% 
  mutate(dist = log(dist))%>% 
  ungroup() %>% #The reverse command of rowwise()
  select(state_seller = state1, state_buyer = state2, dist)
```

## Regressing the indicator variable

In this step the indicator variable of the firm i in the sector S selling to the firm j in the sector S' is explained by the log of the distances between the firm i in the province P and the firm j in the province P'. 

Because of the size of the data set, the amount of data loaded in R simultaneously is a concern. So, the regressions were made by each observation SS' separately instead of grouping by.  

First, the data frame is filtered by the year of interest. Second, a list of all the sectors in the economy is obtained. Third, a dataframe where all the coefficients with their respective observations SS' was created. Fourth, for each pair of sectors SS' in the economy all the firms are combined with each other in the direction of selling-buying. There were two vectors created to store all the firms in each sector (a). The pairs were done by combining a seller with all the possible buyers in the sector, the another seller with all the buyers, and so on (b). It was important to keep the state of each firm and its sector to then join the dataset with the distances and the amounts sold to each firm. Fifth, each combination is added to the original dataframe. Sixth, the distances were matched with their respective combinations of provinces PP'. Seventh, the amount sold by each firm to another one is joined (b) by filtering the original input dataframe by the corresponding observation SS' (a). Eight, as there were missing values as expected, these were replaced with 0 as no sellings were made. Ninth, the indicator variable is created if there were sales made from the firm i to the firm j. Finally, in the tenth place the regression for SS' is made (a) and then appended to the "alpha_ss" dataframe (b). 

```{r data-manipulation-regressions, echo = TRUE}
sales_states_yr <- sales_states %>% # 1
  filter(year == yr) 

sectors <- sales_states_yr %>% #2
  select(sector_seller) %>% 
  unique()

alpha_ss <- data.frame(sector_i = c(NA), sector_j = c(NA), alpha = c(NA)) #3

for (i in sectors$sector_seller){ # 4 (a)
  for (j in sectors$sector_seller){
    sector_i_firms <- sales_states_yr %>% 
      filter(sector_seller == i) %>% 
      select(seller, state_seller, sector_seller) %>% 
      unique()
    
    sector_j_firms <- sales_states_yr %>% 
      filter(sector_buyer == j) %>% 
      select(buyer, state_buyer, sector_buyer) %>%  
      unique()
    
    firms_trade <- data.frame(seller = c(NA), state_seller = c(NA), sector_seller = c(NA), buyer = c(NA), state_buyer = c(NA), sector_buyer = c(NA))
    
    for (k in sector_i_firms$seller){# 4 (b)
      temp_df <- data.frame(seller = k, state_seller = sector_i_firms$state_seller[sector_i_firms$seller == k], sector_seller = sector_i_firms$sector_seller[sector_i_firms$seller == k], buyer = sector_j_firms$buyer)
      temp_df <- left_join(temp_df, sector_j_firms)
      firms_trade <- rbind(firms_trade, temp_df) # 5
    }
    firms_trade <- left_join(firms_trade, distances) # 6
    sales_states_yr_sectors_ij <- sales_states_yr %>% #7 (a)
      filter(sector_seller == i & sector_buyer == j) %>%
      select(-year)
      
    sales_states_yr_sectors_ij_matched <- left_join(firms_trade, sales_states_yr_sectors_ij) %>% # 7 (b)
      mutate(amount = if_else(is.na(amount), 0, amount)) %>% # 8
      mutate(indicator = if_else(amount > 0, 1, 0)) %>% # 9
      filter(seller != is.na(seller))
    
    model <- lm(indicator ~ dist, data = sales_states_yr_sectors_ij_matched) %>% # 10 (a)
      tidy()
    
    alpha_ss <- rbind(alpha_ss, c(i, j, model$estimate[model$term == "(Intercept)"])) # 10 (b)
  }
}

alpha_ss <- alpha_ss %>% 
  filter(sector_i != is.na(sector_i))
```

## Joining the data sets

The datasets are joined by the "state_seller" and "state_buyer" variables and the "n" and "share" variables are kept in the first case and the "share_of_sellers" and "share" in the second one. Also, a the data is sorted to comply with the plot structure. This is accomplished by creating the variable "xpp" which is a sequence from 1 to 400.

```{r joining-the-datasets, echo=TRUE}
final <- merge(number_of_sellers, share_largest_seller) %>% 
  arrange(share) %>% 
  mutate(xpp = seq(n())) %>% 
  select(state_seller, state_buyer, xpp, npp = n)

final_s <- merge(share_of_sellers, share_largest_seller_s) %>% 
  arrange(share_s) %>% 
  mutate(xpp = seq(n())) %>% 
  select(state_seller, state_buyer, xpp, npp = share_sellers) 
```

# Plotting the data

First, three options of graphics are given: area, line and bar plots. The line and area plots have different versions. Then, the graphics are exported to .eps and .png files. 

## Bar plot 

```{r bar-plot, echo=TRUE}
base <- ggplot(data = final, aes(x = xpp, y = npp)) 
b <- base + geom_bar(stat = "identity", fill="#0078b5", width=0.05)
b

base_s <- ggplot(data = final_s, aes(x = xpp, y = npp)) 
b_s <- base_s + geom_bar(stat = "identity", fill="#0078b5", width=0.05)
b_s
```

## Line plot 

```{r line-plot, echo=TRUE}
l1 <- base + geom_line(color="#0078b5", size = 0.25) + ylim(0, 61)
l1
l1_s <- base_s + geom_line(color="#0078b5", size = 0.25) + ylim(0, 1)
l1_s
l2 <- base + geom_line(color="#0078b5", size = 0.25)
l2
l2_s <- base_s + geom_line(color="#0078b5", size = 0.25)
l2_s
```
## Area plot 

```{r area-plot, echo=TRUE}
a1 <- base + geom_area(fill="#0078b5", alpha=0.75)
a1
a1_s <- base_s + geom_area(fill="#0078b5", alpha=0.75)
a1_s
a2 <- base + geom_area(fill="#0078b5", alpha=0.75) + geom_line(color="#0078b5", size = 0.25)
a2
a2_s <- base_s + geom_area(fill="#0078b5", alpha=0.75) + geom_line(color="#0078b5", size = 0.25)
a2_s
```

## Exporting the graphics

Each of the graphics are exported to .eps and .png files. 

```{r exporting-the-graphics, echo=TRUE}
formats <- c("eps", "png", "pdf")
for(i in formats){
  ggsave(filename = paste0("a1.",i), plot = a1, path = "3-Graphics", device = i, width = 7.55, height = 4.25, dpi = 1200)
  ggsave(filename = paste0("a2.",i), plot = a2, path = "3-Graphics", device = i, width = 7.55, height = 4.25, dpi = 1200)
  ggsave(filename = paste0("b.",i), plot = b, path = "3-Graphics", device = i, width = 7.55, height = 4.25, dpi = 1200)
  ggsave(filename = paste0("l1.",i), plot = l1, path = "3-Graphics", device = i, width = 7.55, height = 4.25, dpi = 1200)
  ggsave(filename = paste0("l2.",i), plot = l2, path = "3-Graphics", device = i, width = 7.55, height = 4.25, dpi = 1200)
  ggsave(filename = paste0("a1_s.",i), plot = a1_s, path = "3-Graphics", device = i, width = 7.55, height = 4.25, dpi = 1200)
  ggsave(filename = paste0("a2_s.",i), plot = a2_s, path = "3-Graphics", device = i, width = 7.55, height = 4.25, dpi = 1200)
  ggsave(filename = paste0("b_s.",i), plot = b_s, path = "3-Graphics", device = i, width = 7.55, height = 4.25, dpi = 1200)
  ggsave(filename = paste0("l1_s.",i), plot = l1_s, path = "3-Graphics", device = i, width = 7.55, height = 4.25, dpi = 1200)
  ggsave(filename = paste0("l2_s.",i), plot = l2_s, path = "3-Graphics", device = i, width = 7.55, height = 4.25, dpi = 1200)
}
```